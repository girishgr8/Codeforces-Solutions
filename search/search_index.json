{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"Solutions to Codeforces problems"},{"location":"#getting-started","title":"Getting Started","text":"<p>On this website, you will find the solutions to Codeforces problems in  C++ and Java along with time &amp; space complexities.</p>"},{"location":"dp/01knapsack/","title":"0/1 Knapsack","text":"<p>Approach 1 : Recursion </p> Java <ul> <li> <p> Time Complexity : O(2^(n*W)) where n is number of items, and W is the capacity of knapsack</p> </li> <li> <p> Space Complexity : O(max(n,W)) where n is number of items, and W is the capacity of knapsack</p> </li> </ul> <p>Approach 2 : Memoization </p> Java <ul> <li> <p> Time Complexity : O(n*W) where n is number of items, and W is the capacity of knapsack</p> </li> <li> <p> Space Complexity : O(n*W) where n is number of items, and W is the capacity of knapsack</p> </li> </ul> <p>Approach 3 : Tabulation </p> Java <pre><code>class Solution {\n    public static void main(String[] args) {\n        int W = 50;\n        int n = 3;\n        int[] p = {60, 100, 120};\n        int[] wt = {10, 20, 30};\n\n        int[][] dp = new int[n + 1][W + 1];\n\n        for(int i = 0; i &lt;= n; i++){\n            for(int j = 0; j &lt;= W; j++){\n                if(i == 0 || j == 0)\n                    continue;\n                else if(wt[i-1] &gt; j)\n                    dp[i][j] = dp[i-1][j];\n                else\n                    dp[i][j] = Math.max(dp[i-1][j], (dp[i-1][j-wt[i-1]]+p[i-1]));\n            }\n        }\n        System.out.println(\"Maximum Profit = \" + dp[n][W]);\n    }\n}\n</code></pre> <ul> <li> <p> Time Complexity : O(n*W) where n is number of items, and W is the capacity of knapsack</p> </li> <li> <p> Space Complexity : O(n*W) where n is number of items, and W is the capacity of knapsack</p> </li> </ul>"},{"location":"dp/longestcommonnsubsequence/","title":"Longest Common Subsequence(LCS)","text":"<p>Approach 1 : Recursion </p> Java <pre><code>class Solution {\n    public static void main(String[] args) {\n        String s1 = \"AGGTAB\", s2 = \"GXTXAYB\";\n\n        int m = s1.length(), n = s2.length();\n        int lcs = solve(m-1, n-1, s1, s2);\n        System.out.println(\"Length of LCS = \" + lcs);\n    }\n\n    public static int solve(int i, int j, String s1, String s2){\n        // base case\n        if(i &lt; 0 || j &lt; 0)\n            return 0;\n        // if the current characters of both strings match,\n        // then lcs length = 1 + lcs length for remaining part of these strings\n        if(s1.charAt(i) == s2.charAt(j))\n            return 1 + solve(i-1, j-1, s1, s2);\n        return Math.max(solve(i-1, j, s1, s2), solve(i, j-1, s1, s2));\n    }\n}\n</code></pre> <ul> <li> <p> Time Complexity : O(2<sup>m*n</sup>) where m and n are the length of the two strings</p> </li> <li> <p> Space Complexity : O(max(m,n)) where m and n are the length of the two strings</p> </li> </ul> <p>Approach 2 : Memoization </p> Java <pre><code>\n</code></pre> <ul> <li> <p> Time Complexity : O(m*n) where m and n are the length of the two strings</p> </li> <li> <p> Space Complexity : O(m*n) where m and n are the length of the two strings</p> </li> </ul> <p>Approach 3 : Tabulation </p> Java <pre><code>class Solution {\n    public static void main(String[] args) {\n        String s1 = \"ABCDGH\", s2 = \"AEDFHR\";\n\n        int m = s1.length(), n = s2.length();\n        int[][] dp = new int[m + 1][n + 1];\n\n        for(int i = 0; i &lt; m + 1; i++){\n            for(int j = 0; j &lt; n + 1; j++){\n                if(i == 0 || j == 0)\n                    dp[i][j] = 0;\n                else if(s1.charAt(i-1) == s2.charAt(j-1))\n                    dp[i][j] = 1 + dp[i-1][j-1];\n            else\n                dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\n            }\n        }\n        int lcs = dp[m][n];\n        System.out.println(\"Length of LCS : \" + dp[m][n]);\n\n        char[] str = new char[lcs];\n        int i = m, j = n;\n        while(i &gt; 0 &amp;&amp; j &gt; 0){\n            if(dp[i-1][j] == dp[i][j])\n                i--;\n            else if(dp[i][j-1] == dp[i][j])\n                j--;\n            else{\n                str[--lcs] = s1.charAt(i-1);\n                i--;\n                j--;\n            }\n        }\n        System.out.println(\"LCS is : \" + String.valueOf(str));\n    }\n}\n</code></pre> <ul> <li> <p> Time Complexity : O(m*n) where m and n are the length of the two strings</p> </li> <li> <p> Space Complexity : O(m*n) where m and n are the length of the two strings</p> </li> </ul>"},{"location":"dp/longestcommonsubstring/","title":"Longest Common Substring","text":"<p>Approach : Dynamic Programming - Tabulation </p> Java <pre><code>class Solution {\n    public static void main(String[] args) {\n        String s1 = \"abcdaf\", s2 = \"zbcdf\";\n\n        int m = s1.length(), n = s2.length();\n        int[][] dp = new int[m + 1][n + 1];\n        int r = -1, c = -1, len = 0;\n\n        for(int i = 1; i &lt;= m; i++){\n            for(int j = 1; j &lt;= n; j++){\n                if(s1.charAt(i-1) == s2.charAt(j-1)){\n                    dp[i][j] = 1 + dp[i-1][j-1];\n                    if(len &lt; dp[i][j]){\n                        r = i;\n                        c = j;\n                        len = dp[i][j];\n                    }\n                }\n            }\n        }\n        System.out.println(\"Length of longest common substring : \" + len);\n        char[] str = new char[len];\n        if(r == -1 &amp;&amp; c == -1)\n            System.out.println(\"Longest Common Substring does not exist\");\n        else{\n            while(dp[r][c] &gt; 0){\n                str[--len] = s1.charAt(r-1);\n                r--;\n                c--;\n            }\n            System.out.println(\"Longest Common Substring is : \" + String.valueOf(str));\n        }\n    }\n}\n</code></pre> <ul> <li> <p> Time Complexity : O(m*n) where m and n are the length of the two strings</p> </li> <li> <p> Space Complexity : O(m*n) where m and n are the length of the two strings</p> </li> </ul>"},{"location":"dp/longestincreasingsubsequence/","title":"Longest Increasing Subsequence(LIS)","text":"<p>Approach : Dynamic Programming - Tabulation </p> Java <pre><code>class Solution {\n    public static void main(String[] args) {\n        int[] nums = {10,9,2,5,3,7,101,18};\n        int n = nums.length;\n        int[] dp = new int[n];\n        Arrays.fill(dp, 1);\n        int len = 1;\n        for(int i = 1; i &lt; n; i++){\n            for(int j = 0; j &lt; i; j++){\n                if(nums[j] &lt; nums[i] &amp;&amp; dp[i] &lt;= dp[j])\n                    dp[i] = 1 + dp[j];\n            }\n            len = Math.max(len, dp[i]);\n        }\n        System.out.println(\"Length of LIS = \" + len);\n    }\n}\n</code></pre> <ul> <li> <p> Time Complexity : O(n<sup>2</sup>) where n is the length of the array</p> </li> <li> <p> Space Complexity : O(n) where n is the length of the array</p> </li> </ul>"},{"location":"dp/longestpalindromicsubsequence/","title":"Longest Palindromic Subsequence(LPS)","text":"<ul> <li>Basically, the idea is to find length of LCS of a string and it's reverse</li> </ul> <p>Approach 1 : Recursion </p> Java <pre><code>class Solution {\n    public static void main(String[] args) {\n        String s1 = \"\";\n        String s2 = new StringBuilder(s1).reverse().toString();\n\n        int n = s1.length();\n        int lps = solve(n-1, n-1, s1, s2);\n        System.out.println(\"Length of LPS = \" + lps);\n    }\n\n    public static int solve(int i, int j, String s1, String s2){\n        // base case\n        if(i &lt; 0 || j &lt; 0)\n            return 0;\n        // if the current characters of both strings match,\n        // then lcs length = 1 + lcs length for remaining part of these strings\n        if(s1.charAt(i) == s2.charAt(j))\n            return 1 + solve(i-1, j-1, s1, s2);\n        return Math.max(solve(i-1, j, s1, s2), solve(i, j-1, s1, s2));\n    }\n}\n</code></pre> <ul> <li> <p> Time Complexity : O(2<sup>n*n</sup>) where n is the length of the string</p> </li> <li> <p> Space Complexity : O(n) where n is the length of the string</p> </li> </ul> <p>Approach 2 : Memoization </p> Java <pre><code>\n</code></pre> <ul> <li> <p> Time Complexity : O(n<sup>2</sup>) where n is the length of the string</p> </li> <li> <p> Space Complexity : O(n<sup>2</sup>) where n is the length of the string</p> </li> </ul> <p>Approach 3 : Tabulation </p> Java <pre><code>class Solution {\n    public static void main(String[] args) {\n        String s1 = \"\";\n        String s2 = new StringBuilder(s1).reverse().toString();\n\n        int n = s1.length();\n        int[][] dp = new int[n + 1][n + 1];\n\n        for(int i = 1; i &lt;= n; i++){\n            for(int j = 1; j &lt;= n; j++){\n                if(s1.charAt(i-1) == s2.charAt(j-1))\n                    dp[i][j] = 1 + dp[i-1][j-1];\n            else\n                dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\n            }\n        }\n        System.out.println(\"Length of LPS = \" + dp[n][n]);\n    }\n}\n</code></pre> <ul> <li> <p> Time Complexity : O(n<sup>2</sup>) where n is the length of the string</p> </li> <li> <p> Space Complexity : O(n<sup>2</sup>) where n is the length of the string</p> </li> </ul>"},{"location":"dp/mincoinchange/","title":"Coin Change - minimum number of coins to make the change","text":"<p>Approach 1 : Recursion </p> Java <pre><code>class Solution{\n    public static void main(String[] args) {\n        int[] coins = {1, 5, 7};\n        int n = 18;\n        int minCoins = solve(n, coins);\n        System.out.println(\"To make a change of \" + n +\", minimum coins needed are \" + minCoins);\n    }\n\n    public static int solve(int n, int[] coins){\n        if(n == 0)\n            return 0;\n    int minimum = Integer.MAX_VALUE;\n    for(int i = 0; i &lt; coins.length; i++){\n        if(n-coins[i] &gt;= 0){\n            int subMin = solve(n-coins[i], coins);\n            if(subMin != Integer.MAX_VALUE &amp;&amp; subMin + 1 &lt; minimum)\n                minimum = 1 + subMin;\n        }\n    }\n    return minimum;\n    }\n}\n</code></pre> <ul> <li> <p> Time Complexity : O(2^(n*V)) where n is number of different coins, and V is the change to make</p> </li> <li> <p> Space Complexity : O(max(n,V)) where n is number of different coins, and V is the change to make</p> </li> </ul> <p>Approach 3 : Tabulation </p> Java <pre><code>class Solution {\n    public static void main(String[] args) {\n        int[] coins = {1, 5, 7};\n        int n = 14;\n        int totalCoins = coins.length;\n        int[] dp = new int[n + 1];\n        Arrays.fill(dp, Integer.MAX_VALUE);\n        dp[0] = 0;\n        for(int i = 1; i &lt; dp.length; i++){\n            for(int j = 0; j &lt; totalCoins; j++){\n                if(coins[j] &lt;= i){\n                    int min = dp[i-coins[j]];\n                    if(min != Integer.MAX_VALUE &amp;&amp; min + 1 &lt; dp[i])\n                        dp[i] = min + 1;\n                }\n            }\n        }\n        int minCoins = dp[n];\n        if(minCoins != Integer.MAX_VALUE)\n            System.out.println(\"To make a change of \" + n +\", minimum coins needed are \" + minCoins);\n        else\n            System.out.println(\"We cannot make a change of \" + n +\" using given coins\");\n    }\n}\n</code></pre> <ul> <li> <p> Time Complexity : O(n*V) where n is number of different coins, and V is the change to make</p> </li> <li> <p> Space Complexity : O(n*V) where n is number of different coins, and V is the change to make</p> </li> </ul>"},{"location":"problems/1475/A/","title":"A. Odd Divisors","text":"C++Java <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll              long long int\n#define ulli            unsigned long long int\n#define li              long int\n\nint main()\n{\n    int t;\n    cin &gt;&gt; t;\n    while (t-- &gt; 0)\n    {\n        long long int n;\n        cin &gt;&gt; n;\n        if ((n &amp; (n - 1)) != 0)\n            cout &lt;&lt; \"YES\" &lt;&lt; endl;\n        else\n            cout &lt;&lt; \"NO\" &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre> <pre><code>import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        FastReader sc = new FastReader();\n        int t = sc.nextInt();\n        while (t-- &gt; 0) {\n            long n = sc.nextLong();\n            if ((n &amp; (n - 1)) != 0)\n                System.out.println(\"YES\");\n            else\n                System.out.println(\"NO\");\n        }\n    }\n}\n</code></pre> <ul> <li> Time Complexity : O(1)</li> <li> Space Complexity : O(1)</li> </ul>","tags":["math","number theory","*900"]},{"location":"problems/1475/B/","title":"B. New Year's Number","text":"","tags":["brute force","dp","math","*900"]},{"location":"problems/1475/B/#approach-1-bottom-up-dynamic-programming","title":"Approach 1: Bottom-Up Dynamic Programming","text":"C++Java <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll long long int\n#define ulli unsigned long long int\n#define li long int\n#define N 1000000\n\nvoid solve(vector`&lt;bool&gt;` &amp;dp)\n{\n    dp[0] = true;\n    for (int i = 2020; i &lt;= N; i++)\n    {\n        if (dp[i - 2020] == true || dp[i - 2021] == true)\n            dp[i] = true;\n    }\n}\n\nint main()\n{\n    int t;\n    cin &gt;&gt; t;\n    vector`&lt;bool&gt;` dp(N + 1, false);\n    solve(dp);\n\nwhile (t-- &gt; 0)\n    {\n        int n;\n        cin &gt;&gt; n;\n        if (dp[n] == true)\n            cout &lt;&lt; \"YES\" &lt;&lt; endl;\n        else\n            cout &lt;&lt; \"NO\" &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre> <pre><code>import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    private static final int N = 1000000;\n\npublic static void solve(boolean[] dp) {\n        dp[0] = true;\n        for (int i = 2020; i &lt;= N; i++) {\n            if (dp[i - 2020] == true || dp[i - 2021] == true)\n                dp[i] = true;\n        }\n    }\n\npublic static void main(String[] args) {\n        FastReader sc = new FastReader();\n        int t = sc.nextInt();\n        boolean[] dp = new boolean[N + 1];\n        solve(dp);\n\nwhile (t-- &gt; 0) {\n            int n = sc.nextInt();\n            if (dp[n] == true)\n                System.out.println(\"YES\");\n            else\n                System.out.println(\"NO\");\n        }\n    }\n}\n</code></pre> <ul> <li> Time Complexity : O(N) where <code>N</code> = 10<sup>6</sup></li> <li> Space Complexity : O(N) where <code>N</code> = 10<sup>6</sup></li> </ul>","tags":["brute force","dp","math","*900"]},{"location":"problems/1475/B/#approach-2-mathematical","title":"Approach 2: Mathematical","text":"C++Java <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll long long int\n#define ulli unsigned long long int\n#define li long int\n\nint main()\n{\n    int t;\n    cin &gt;&gt; t;\n\nwhile (t-- &gt; 0)\n    {\n        int n;\n        cin &gt;&gt; n;\n        int y = n % 2020;\n        int x = (n - y) / 2020 - y;\n        if (x &gt;= 0 &amp;&amp; (x * 2020 + y * 2021) == n)\n            cout &lt;&lt; \"YES\" &lt;&lt; endl;\n        else\n            cout &lt;&lt; \"NO\" &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre> <pre><code>import java.util.*;\nimport java.io.*;\n\nclass Main {\n    public static void main(String[] args) {\n        FastReader sc = new FastReader();\n        int t = sc.nextInt();\n\nwhile (t-- &gt; 0) {\n            int n = sc.nextInt();\n            int y = n % 2020;\n            int x = (n - y) / 2020 - y;\n            if (x &gt;= 0 &amp;&amp; (x * 2020 + y * 2021) == n)\n                System.out.println(\"YES\");\n            else\n                System.out.println(\"NO\");\n        }\n    }\n}\n</code></pre> <ul> <li> Time Complexity : O(t) where <code>t</code> is number of testcases</li> <li> Space Complexity : O(1)</li> </ul>","tags":["brute force","dp","math","*900"]},{"location":"problems/1974/A/","title":"A. Phone Desktop","text":"C++Java <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll long long int\n#define ulli unsigned long long int\n#define li long int\n\nvoid solve(int x, int y)\n{\n    int two_must = y / 2;\n    int two_extra = y % 2;\n    int total = two_must + two_extra;\n    int one_that_can_fit = 7 * two_must + 11 * two_extra;\n    if (x &gt; one_that_can_fit)\n    {\n        int one_extra = (x - one_that_can_fit);\n        total += (one_extra / 15) + (one_extra % 15 &gt; 0 ? 1 : 0);\n    }\n    cout &lt;&lt; total &lt;&lt; endl;\n    return;\n}\n\nint main()\n{\n    int t;\n    cin &gt;&gt; t;\n\n    while (t-- &gt; 0)\n    {\n        int x, y;\n        cin &gt;&gt; x &gt;&gt; y;\n        solve(x, y);\n    }\n    return 0;\n}\n</code></pre> <pre><code>import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void solve(int x, int y) {\n        int two_must = y / 2;\n        int two_extra = y % 2;\n        int total = two_must + two_extra;\n        int one_that_can_fit = 7 * two_must + 11 * two_extra;\n        if (x &gt; one_that_can_fit) {\n            int one_extra = (x - one_that_can_fit);\n            total += (one_extra / 15) + (one_extra % 15 &gt; 0 ? 1 : 0);\n        }\n        System.out.println(total);\n        return;\n    }\n\n    public static void main(String[] args) {\n        FastReader sc = new FastReader();\n        int t = sc.nextInt();\n        while (t-- &gt; 0) {\n            int x = sc.nextInt(), y = sc.nextInt();\n            solve(x, y);\n        }\n    }\n}\n</code></pre> <ul> <li> Time Complexity : O(t) where <code>t</code> is number of testcases</li> <li> Space Complexity : O(1)</li> </ul>","tags":["greedy","math","*800"]},{"location":"problems/1975/A/","title":"A. Bazoka and Mocha's Array","text":"C++Java <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll long long int\n#define ulli unsigned long long int\n#define li long int\n\nvoid solve(vector`&lt;int&gt;` &amp;arr){\n    int n = arr.size();\n    int peakIndex = -1;\n    for (int i = 0; i &lt; n - 1; i++)\n    {\n        if (arr[i] &gt; arr[i + 1])\n        {\n            peakIndex = i;\n            break;\n        }\n    }\n    if (peakIndex == -1)\n    {\n        cout &lt;&lt; \"Yes\" &lt;&lt; endl;\n    }\n    else\n    {\n        bool notPossible = false;\n        for (int i = peakIndex + 1; i &lt; n; i++)\n        {\n            int j = (i + 1) % n;\n            if (arr[j] &lt; arr[i])\n            {\n                notPossible = true;\n                break;\n            }\n        }\n        if (notPossible == false)\n            cout &lt;&lt; \"Yes\" &lt;&lt; endl;\n        else\n            cout &lt;&lt; \"No\" &lt;&lt; endl;\n    }\n}\n\nint main()\n{\n    int t;\n    cin &gt;&gt; t;\n\nwhile (t-- &gt; 0)\n    {\n        int n;\n        cin &gt;&gt; n;\n        vector`&lt;int&gt;` arr;\n        for (int i = 0; i &lt; n; i++)\n        {\n            int num;\n            cin &gt;&gt; num;\n            arr.push_back(num);\n        }\n        solve(arr);\n    }\n    return 0;\n}\n</code></pre> <pre><code>import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void solve(int[] arr) {\n        int n = arr.length;\n        int peakIndex = -1;\n        for (int i = 0; i &lt; n - 1; i++) {\n            if (arr[i] &gt; arr[i + 1]) {\n                peakIndex = i;\n                break;\n            }\n        }\n        if (peakIndex == -1)\n            System.out.println(\"Yes\");\n        else {\n            boolean notPossible = false;\n            for (int i = peakIndex + 1; i &lt; n; i++) {\n                int j = (i + 1) % n;\n                if (arr[j] &lt; arr[i]) {\n                    notPossible = true;\n                    break;\n                }\n            }\n            if (notPossible == false)\n                System.out.println(\"Yes\");\n            else\n                System.out.println(\"No\");\n        }\n    }\n\npublic static void main(String[] args) {\n        FastReader sc = new FastReader();\n        int t = sc.nextInt();\n        while (t-- &gt; 0) {\n            int n = sc.nextInt();\n            int[] arr = new int[n];\n            for (int i = 0; i &lt; n; i++)\n                arr[i] = sc.nextInt();\n            solve(arr);\n        }\n    }\n}\n</code></pre> <ul> <li> Time Complexity : O(t * n) where <code>t</code> is number of testcases and <code>n</code> is the length of array</li> <li> Space Complexity : O(1)</li> </ul>","tags":["brute force","implementation","sortings"]},{"location":"problems/1975/B/","title":"B. 378QAQ and Mocha's Array","text":"C++Java <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n#define ll long long int\n#define ulli unsigned long long int\n#define li long int\n\nint gcd(int a, int b)\n{\n    if (a == 0)\n        return b;\n    return gcd(b % a, a);\n}\n\nvoid solve(vector`&lt;int&gt;` &amp;arr)\n{\n    int n = arr.size(), i = 0, j = -1;\n    if (arr[i] == 1)\n    {\n        cout &lt;&lt; \"Yes\" &lt;&lt; endl;\n        return;\n    }\n    for (int k = 1; k &lt; n; k++)\n    {\n        if (gcd(arr[i], arr[k]) != arr[i])\n        {\n            j = k;\n            break;\n        }\n    }\n    if (j == -1)\n    {\n        cout &lt;&lt; \"Yes\" &lt;&lt; endl;\n        return;\n    }\n    for (int k = 0; k &lt; n; k++)\n    {\n        if (!(arr[k] % arr[i] == 0 || arr[k] % arr[j] == 0))\n        {\n            System.out.println(\"No\");\n            return;\n        }\n    }\n    cout &lt;&lt; \"Yes\" &lt;&lt; endl;\n    return;\n}\n\nint main()\n{\n    int t;\n    cin &gt;&gt; t;\n\nwhile (t-- &gt; 0)\n    {\n        int n;\n        cin &gt;&gt; n;\n        vector`&lt;int&gt;` arr;\n        for (int i = 0; i &lt; n; i++)\n        {\n            int num;\n            cin &gt;&gt; num;\n            arr.push_back(num);\n        }\n        sort(arr.begin(), arr.end());\n        solve(arr);\n    }\n    return 0;\n}\n</code></pre> <pre><code>import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static int gcd(int a, int b) {\n        if (a == 0)\n            return b;\n        return gcd(b % a, a);\n    }\n\npublic static void solve(int[] arr) {\n        int n = arr.length, i = 0, j = -1;\n        if (arr[i] == 1) {\n            System.out.println(\"Yes\");\n            return;\n        }\n        for (int k = 1; k &lt; n; k++) {\n            if (gcd(arr[i], arr[k]) != arr[i]) {\n                j = k;\n                break;\n            }\n        }\n        if (j == -1) {\n            System.out.println(\"Yes\");\n            return;\n        }\n        for (int k = 0; k &lt; n; k++) {\n            if (!(arr[k] % arr[i] == 0 || arr[k] % arr[j] == 0)) {\n                System.out.println(\"No\");\n                return;\n            }\n        }\n        System.out.println(\"Yes\");\n        return;\n    }\n    public static void main(String[] args) {\n        FastReader sc = new FastReader();\n        int t = sc.nextInt();\n        while (t-- &gt; 0) {\n            int n = sc.nextInt();\n            int[] arr = new int[n];\n            for (int i = 0; i &lt; n; i++)\n                arr[i] = sc.nextInt();\n            Arrays.sort(arr);\n            solve(arr);\n        }\n    }\n}\n</code></pre> <ul> <li> Time Complexity : O(t * n * logN ) where <code>t</code> is number of testcases, <code>n</code> is the length of array and <code>N</code> = max(<code>a[i]</code>)</li> <li> Space Complexity : O(1)</li> </ul>","tags":["brute force","greedy","math","sortings"]},{"location":"tags/","title":"Tags","text":"<p>Following is a list of tags:</p>"},{"location":"tags/#800","title":"*800","text":"<ul> <li>A. Phone Desktop</li> </ul>"},{"location":"tags/#900","title":"*900","text":"<ul> <li>A. Odd Divisor</li> <li>B. New Year's Number</li> </ul>"},{"location":"tags/#brute-force","title":"brute force","text":"<ul> <li>B. New Year's Number</li> <li>A. Bazoka and Mocha's Array</li> <li>B. 378QAQ and Mocha's Array</li> </ul>"},{"location":"tags/#dp","title":"dp","text":"<ul> <li>B. New Year's Number</li> </ul>"},{"location":"tags/#greedy","title":"greedy","text":"<ul> <li>A. Phone Desktop</li> <li>B. 378QAQ and Mocha's Array</li> </ul>"},{"location":"tags/#implementation","title":"implementation","text":"<ul> <li>A. Bazoka and Mocha's Array</li> </ul>"},{"location":"tags/#math","title":"math","text":"<ul> <li>A. Odd Divisor</li> <li>B. New Year's Number</li> <li>A. Phone Desktop</li> <li>B. 378QAQ and Mocha's Array</li> </ul>"},{"location":"tags/#number-theory","title":"number theory","text":"<ul> <li>A. Odd Divisor</li> </ul>"},{"location":"tags/#sortings","title":"sortings","text":"<ul> <li>A. Bazoka and Mocha's Array</li> <li>B. 378QAQ and Mocha's Array</li> </ul>"}]}